<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Red-c-sdk by PhongPham101190</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Red-c-sdk</h1>
      <h2 class="project-tagline">MEGA SDK - Client Access Engine Coverity Scan Build Status MEGA --- The Privacy Company --- is a Secure Cloud Storage provider that protects your data thanks to end-to-end encryption. We call it User Controlled Encryption, or UCE, and all our clients automatically manage it.  All files stored on MEGA are encrypted. All data transfers from and to MEGA are encrypted. And while most cloud storage providers can and do claim the same, MEGA is different – unlike the industry norm where the cloud storage provider holds the decryption key, with MEGA, you control the encryption, you hold the keys, and you decide who you grant or deny access to your files.  This SDK brings you all the power of our client applications and let you create your own or analyze the security of our products. Are you ready to start? Please continue reading.  SDK Contents  In this SDK, you can find our low level SDK, that was already released few months after the MEGA launch, a new intermediate layer to make it easier to use and to bind with other programming languages, and example apps for all our currently supported platforms (Windows, Linux, OSX, Android, iOS and Windows Phone).  In the examples folder you can find example apps using:  The low level SDK:  megacli (a powerful command line tool that allows to use all SDK features) megasimplesync (a command line tool that allows to use the synchronization engine) The intermediate layer:  An example app for Visual Studio in examples/win32 An example app for Android (using Java bindings based on SWIG) in examples/android An example app for iOS (using Objective-C bindings) in examples/iOS An example app for Windows Phone (using Windows Phone bindings) in examples/wp8 Building  If you plan to develop an app using this SDK, please use the stable branch or the last released tarball. The master branch is continuously evolving, could be unstable and could change very often.  For platforms with Autotools, the generic way to build and install it is:  sh autogen.sh ./configure make sudo make install That compilation will include the examples using our low level SDK (megacli and megasimplesync) You also have specific build instructions for OSX (doc/OSX.txt) and FreeBSD (doc/FreeBSD.txt) and a build script to automatically download and build the SDK along with all its dependencies (contrib/build_sdk.sh)  For other platforms, or if you want to see how to use the new intermediate layer, the easiest way is to get a smooth start is to build one of the examples in subfolders of the examples folder.  All these folders contains a README.md file with information about how to get the project up and running, including the installation of all required dependencies.  Usage  The low level SDK doesn&#39;t have inline documentation yet. If you want to use it, please check one of our example apps (examples/megacli, examples/megasimplesync).  The new intermediate layer has been documented using Doxygen. The only public header that you need to include to use is include/megaapi.h. You can read the documentation in that header file, or download the same documentation in HTML format from this link:  https://mega.co.nz/#!c5FzhBJL!HUVjsOJTylwkmXPZ0AxT66Wuu4YvZInyHbWGYgvTHt4  Additional info  Platform Dependencies  Dependencies are different for each platform because the SDK uses generic interfaces to get some features and they have different implentations:  Network (cURL with OpenSSL/c-ares or WinHTTP) Filesystem access (Posix or Win32) Graphics management (FreeImage, QT or iOS frameworks) Database (SQLite or Berkeley DB) Threads/mutexes (Win32, pthread, QT threads, or C++11) POSIX (Linux/Darwin/BSD/OSX ...)  Install the following development packages, if available, or download and compile their respective sources (package names are for Debian and RedHat derivatives, respectively):  cURL (libcurl4-openssl-dev, libcurl-devel), compiled with --enable-ssl c-ares (libc-ares-dev, libcares-devel, c-ares-devel) OpenSSL (libssl-dev, openssl-devel) Crypto++ (libcrypto++-dev, libcryptopp-devel) zlib (zlib1g-dev, zlib-devel) SQLite (libsqlite3-dev, sqlite-devel) or configure --without-sqlite FreeImage (libfreeimage-dev, freeimage-devel) or configure --without-freeimage pthread Optional dependency:  Sodium (libsodium-dev, libsodium-devel), configure --with-sodium Filesystem event monitoring: The provided filesystem layer implements the Linux inotify and the MacOS fsevents interfaces.  To build the reference megacli example, you may also need to install:  GNU Readline (libreadline-dev, readline-devel) For Android, we provide an additional implementation of the graphics subsystem using Android libraries.  For iOS, we provide an additional implementation of the graphics subsystem using Objective C frameworks.  Windows  To build the client access engine under Windows, you&#39;ll need the following:  A Windows-native C++ development environment (e.g. MinGW or Visual Studio) Crypto++ zlib (until WinHTTP learns how to deal with Content-Encoding: gzip) SQLite or configure --without-sqlite FreeImage or configure --without-freeimage pthreads (MinGW) Optional dependency:  Sodium or configure --with-sodium To build the reference megacli.exe example, you will also need to procure development packages (at least headers and .lib/.a libraries) of:  GNU Readline/Termcap Folder syncing  In this version, the sync functionality is limited in scope and functionality:  There is no locking between clients accessing the same remote folder. Concurrent creation of identically named files and folders can result in server-side dupes.  Syncing between clients with differing filesystem naming semantics can lead to loss of data, e.g. when syncing a folder containing ABC.TXT and abc.txt with a Windows client.  On POSIX platforms, filenames are assumed to be encoded in UTF-8. Invalid byte sequences can lead to undefined behaviour.  Local filesystem items must not be exposed to the sync subsystem more than once. Any dupes, whether by nesting syncs or through filesystem links, will lead to unexpected results and loss of data.  No in-place versioning. Deleted remote files can be found in //bin/SyncDebris (only when syncing to the logged in account&#39;s own cloud drive - there is no SyncDebris facility on syncs to inbound shares), deleted local files in a sync-specific hidden debris folder located in the local sync&#39;s root folder.  No delta writes. Changed files are always overwritten as a whole, which means that it is not a good idea to sync e.g. live database tables.  No direct peer-to-peer syncing. Even two machines in the same local subnet will still sync via the remote storage infrastructure.  No support for unidirectional syncing (backup-only, restore-only). Syncing to an inbound share requires it to have full access rights.  megacli on Windows  The megacli example is currently not handling console Unicode input/output correctly if run in cmd.exe.  Filename caveats: Please prefix all paths with \\?\ to avoid the following issues:  The MAX_PATH (260 character) length limitation, which would make it impossible to access files in deep directory structures  Prohibited filenames (con/prn/aux/clock$/nul/com1...com9/lpt1...lpt9). Such files and folders will still be inaccessible through e.g. Explorer!  Also, disable automatic short name generation to eliminate the risk of clashes with existing short names.</h2>
      <a href="https://github.com/PhongPham101190/Red-C-SDK" class="btn">View on GitHub</a>
      <a href="https://github.com/PhongPham101190/Red-C-SDK/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/PhongPham101190/Red-C-SDK/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to GitHub Pages.</h3>

<p>This automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here <a href="https://guides.github.com/features/mastering-markdown/">using GitHub Flavored Markdown</a>, select a template crafted by a designer, and publish. After your page is generated, you can check out the new <code>gh-pages</code> branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.</p>

<h3>
<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span class="octicon octicon-link"></span></a>Designer Templates</h3>

<p>We’ve crafted some handsome templates for you to use. Go ahead and click 'Continue to layouts' to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved.</p>

<h3>
<a id="creating-pages-manually" class="anchor" href="#creating-pages-manually" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating pages manually</h3>

<p>If you prefer to not use the automatic generator, push a branch named <code>gh-pages</code> to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.</p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>You can <a href="https://github.com/blog/821" class="user-mention">@mention</a> a GitHub username to generate a link to their profile. The resulting <code>&lt;a&gt;</code> element will link to the contributor’s GitHub Profile. For example: In 2007, Chris Wanstrath (<a href="https://github.com/defunkt" class="user-mention">@defunkt</a>), PJ Hyett (<a href="https://github.com/pjhyett" class="user-mention">@pjhyett</a>), and Tom Preston-Werner (<a href="https://github.com/mojombo" class="user-mention">@mojombo</a>) founded GitHub.</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with Pages? Check out our <a href="https://help.github.com/pages">documentation</a> or <a href="https://github.com/contact">contact support</a> and we’ll help you sort it out.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/PhongPham101190/Red-C-SDK">Red-c-sdk</a> is maintained by <a href="https://github.com/PhongPham101190">PhongPham101190</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
